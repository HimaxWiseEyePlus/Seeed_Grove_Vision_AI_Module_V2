# WW500 BLE commands
#### CGP 5 August 2025

When the smartphone app establishes a BLE connection to the WW500 it can send and receive messages.
The messages that it sends are treated as commands to the WW500. The messages it receives are 
either responses to those messages, or spontaneously generated messages.

## Commands Overview

When a smartphone app is connected to the WW500, text sent from the app to the WW500 is parsed,
and if the text represents known commands then the text is passed to appropriate functions for action. 
Responses are returned.

* Commands that are __not__ beginning with `AI ` are treated as commands for the BLE processor (the MKL62BA module).
In that case, responses are generated by the BLE processor and returned to the app.
* Commands that __are__ beginning with `AI ` are treated as commands for the AI processor (the HX6538 chip),
and passed on to the AI  processor for parsing and execution. In that case, responses are
transferred from the AI processor to the BLE processor before being returned to the app.
* Commands for the AI processor are processed by the command line interface (CLI) so the same commands
can be sent by the app or by typing at the console. The BLE processor does not have a CLI.

This document describes these commands. Some commands are now redundant and can be removed. There is 
scope for adding additional commands.

Of course, it is possible to change the command syntax and responses - developers should request that.

## Spontaneous Messages

There are some messages sent to the app which are not responses to an app command. These include:
* Spontaneous messages from the BLE processor, such as those reporting LoRaWAN traffic.
* Spontaneous messages from the AI processor, such as those reporting camera and neural network operation.
* Messages  from the AI processor mainly intended for the BLE processor - in particular "Sleep" and "Wake" messages that indicate when the AI processor
enters and leaves DPD mode.
 
Those messages are not documented in this document. (These will follow in a separate document or a 
later version of this document.)

## Commands for the BLE Processor

For a definitive list of the commands recognised by the BLE processor developers should view the 
[ble_commands.c](https://github.com/wildlifeai/ww-hardware/blob/main/MokoTech/Workspace/WildlifeWatcher_1/ble_commands.c) file 
and look at the [appCommands[]](https://github.com/wildlifeai/ww-hardware/blob/main/MokoTech/Workspace/WildlifeWatcher_1/ble_commands.c#L131) array.

The first few lines of that array are shown below. Each entry contains the text to match then the function that is 
called to process the command.

```c
struct CmdStruct appCommands[] = {
		{"ping", processPing},						// Send LoRaWan packet
		{"enable", processEnable},					// Enable reporting of sensor events
		{"disable", processDisable},				// Disable reporting of sensor events
		{"status",  processStatus},					// Report some state
		{"battery", processBattery},				// Report battery volatge
		{"id", processID},							// Send BLE name
		{"ver", processVer},						// Send firmware version etc
		<snip>
		}
}
``` 

The table below lists all of the commands. The command set has evolved over time and includes commands that are no longer useful,
or at least need to be implemented in the app.
The "Reqd?" column indicates whether the command should be implemented by the app, or notes below. 

| Command        | Parameter(s)  | Response                                      | Reqd? |
|----------------|---------------|-----------------------------------------------|-------|
| (unrecognised) |               | "Unrecognised"                                | -     |
| id             |               | Device's BLE name e.g. 'WILD-EP5Y'            | Y     |
| ver            |               | Device type, s/w version, build date          | Y     |
| ping           |               | 'OK' followed some time later by the          | Y     |
|                |               | response from attempted LoRaWAN ping          |       |
| enable         |               | Obsolete: "Sensor messages are enabled"       | N     |
| disable        |               | Obsolete: "Sensor messages are disabled"      | N     |
| status         |               | Some status info                              | Y     |
| battery        |               | Voltage and percent charge:                   | Y     |
|                |               | "Battery = 3210mV 95%"                        |       |
| device         |               | Hardware type e.g. "WW500-A00"                | Y     |
| get heatbeat   |               | Reports LoRaWAN heartbeat period e.g. "4h"    | y     |
| heartbeat      | 30m, 2h etc   | Sets heartbeat interval e.g.                  | Y     |
|                |               |   "heartbeat 30m = OK"                        |       |
| get deveui     |               | 8-byte EUI                                    | Y     |
| get appeui     |               | 8-byte EUI                                    | Y     |
| get appkey     |               | "failed 2"                                    | 1     |
| deveui         | 8-byte EUI    | Sets BLE DevEUI                               | 2     |
|                |               | 'deveui 11:22:33:44:55:66:77:88'              |       |
| appeui         | 8-byte EUI    | Sets BLE AppEUI                               | 2     |
|                |               | 'appeui 11:22:33:44:55:66:77:88'              |       |
| appkey         | 16-byte EUI   | Sets BLE AppKey                               | 2     |
|                |               | 'appkey 11:22:33:44:55:66:77:88:11:22:33:44:55:66:77:88' |       |
| reset          |               | "device will reset after disconnecting"       | 2     |
| erase          |               | "device will erase after disconnecting"       | 2     |
| dis            |               | Disconnect BLE session                        | Y     |
| dfu            |               | Places device in DFU mode for s/w upgrade     | Y     |
| gpio           | GPIO pin      | Reports whether the GPIO pin is driven        | 2     |
| set gpio       | GPIO pin      | Sets a GPIO pin high                          | 2     |
| clr gpio       | GPIO pin      | Sets a GPIO pin low                           | 2     |
| get gpio       | GPIO pin      | Reads the state of a GPIO pin                 | 2     |
| send           | Number of bytes | Send bytes to the app                       | 2     |
| wake           | A delay in us | Pulses a pin to wake the HX6538 from DPD      | 2     |
| setutc         | UTC string    | Sets BLE processor UTC time                   | Y, 3  |
|                |               | UTC format is  "YYYY-MM-DDTHH:MM:SSZ"         |       |
|                |               | Response: "UTC is 2025-02-03T01:02:03Z        |       |
| getutc         |               | Gets the UTC time                             | Y, 3  |
| setgps         | GPS string    | Sets app location                             | Y, 4  |
|                |               | GPS format is  "20°48'30.50\"_N_100°25'10.22\"_W_20.3_Above" |       |
|                |               | Response: "Location is: 20°48'30.50\"_N_100°25'10.22\"_W_20.3_Above" |       |
| getgps         |               | Gets the GPS string                           | Y, 4  |
| getops         |               | Requests all the Operational Parameters       | Y, 5  |
| join           |               | Request to join LoRaWAN network               | Y, 5  |
| network        |               | LoRaWAN network statistics, e.g.:             | Y, 5  |
|                |               | "RSSI: -44dB, SNR: 3dB, PER: 2%. Last seen 3  minutes ago."|       |
|                |               | Or: "No network comms yet."                   |      |
| getnnstats     |               | Returns neural network processing actions and positive ids | 2     |
| setnnstats     | n, m          | Setter for getnnstats - development only      | 2     |

__Notes:__
1. The API does not permit reading the appkey
2. Not needed by app but used for development and testing purposes, and can be accessed by nRFToolbox. 
(Would be useful for engineering, but not essential).
If the app has commands for these now they should be removed for production version.
Perhaps I will remove these before shipping production units.
3. See below "Setting UTC time"
4. See below "Setting GPS location"
5. Implemented in v806 firmware

## Commands for the AI Processor

Commands for the AI processor are handled by the CLI (command line interface) functions. These commands can be executed
by typing at the console. The same commands can be sent by the app, preceded by the 'AI ' characters.

For a definitive list of the commands recognised by the AI processor developers should type `help`
at the AI processor console - this summarises all available commands.

Developers can also view the 
[CLI-commands.c](https://github.com/wildlifeai/Seeed_Grove_Vision_AI_Module_V2/blob/main/EPII_CM55M_APP_S/app/ww_projects/ww500_md/CLI-commands.c) file 
and look at the [vRegisterCLICommands()](https://github.com/wildlifeai/Seeed_Grove_Vision_AI_Module_V2/blob/main/EPII_CM55M_APP_S/app/ww_projects/ww500_md/CLI-commands.c#L1743) function.
Also, for SD-card related commands, view the 
[CLI-FATFS-commands.c](https://github.com/wildlifeai/Seeed_Grove_Vision_AI_Module_V2/blob/main/EPII_CM55M_APP_S/app/ww_projects/ww500_md/CLI-FATFS-commands.c) file
and look at the [vRegisterCLICommands()](https://github.com/wildlifeai/Seeed_Grove_Vision_AI_Module_V2/blob/main/EPII_CM55M_APP_S/app/ww_projects/ww500_md/CLI-FATFS-commands.c#L623C13-L623C33) function.

The table below lists only some of the commands. The command set has evolved over time and includes commands that are no 
longer useful, or at least need to be implemented in the app.
The "Reqd?" column indicates whether the command should be implemented by the app, or notes below. 

| Command        | Parameter(s)  | Response                                      | Reqd? |
|----------------|---------------|-----------------------------------------------|-------|
| AI (unrecognised) |            | "Unrecognised"                                | -     |
| AI ver         |               | Returns device name and s/w build date        | Y     |
| AI enable      |               | Enables the camera system                     | Y     |
| AI disable     |               | Disabled the camera system                    | Y     |
| AI status      |               | Reports whether the camera is enabled         | Y     |
| AI getop       | n             | Requests the value of Operational Parameter n | Y, 4  |
| AI setop       | n m           | Sets the value of Operational Parameter n to m | Y, 4   |
| AI capture     | n m           | Trigger capture of n images at m millisecond intervals  | Y     |
| AI txfile      | filename, or '.' | File contents returned in several chunks   | Y, 3  |

Note that there are addition commands that could be run on the AI processor, not documented here.
These can be seen by typing "help" at the console. 

__Notes:__
1. See below "Setting UTC time"
2. See below "Setting GPS location"
3. See separate document [txfile.md](txfile.md) for the details.
4. Set and get Operational Parameters. See [Operational_Parameters.md](Operational_Parameters.md)

__Other AI Processor Commands__
If you type "help" at the console of the AI processor you will see all of the commands that the AI processor has.
Only some have been documented in the table above. All of them can be issued via the app by prefixing "AI ".
Some might be useful in due course, such as those for navigating the file system.

__Asynchronous Messages__

At present, some messages from the LoRaWAN code and other sources are sent asynchronously via BLE messages, such as:
* "uplink message acknowldeged"
* "Downlink message: RSSI=11dBm SNR=14dB Rx 5 bytes"
These have been useful for engineering purposes. Let me know is you need more details, for parsing purposes.
For example, I could prefix useful engineering messages with some character so the app can discard these.  

Some of these messages are documented un the table below.

| Message   | Parameter(s)                  | Example  | Notes	                                            | 
|-----------|-------------------------------|----------|------------------------------------------------------|
| Wake      | The AI processor's UTC time   | ```Wake 2025-06-23T2:33:22Z``` | Sent by AI processor when it leaves DPD.             |
| Sleep     | All the Operational Paramters | ```Sleep 723 723 60 25 667 2 2000 60 3000 5 0 500``` |Sent by AI processor when it enters DPD. See [ Operational_Parameters.md](Operational_Parameters.md) |
| Event     | All the Operational Parameters | ```Event 723 723 60 25 667 2 2000 60 3000 5 0 500```   | Sent by AI processor when NN detects target. See [Operational_Parameters.md](Operational_Parameters.md) |
| MD        | The AI processor's UTC time   | ```MD 2025-06-23T2:33:22Z```  | Sent by AI processor when it detects motion          |
| NN+       |                               | ```NN+``` | Sent by AI processor when the NN detects its target. |
| NN:       | Number of positive NN events  | ```NN: 234``` | Printed when the number of NN positive events increments. |

The Wake and Sleep messages are intended to allow the BLE processor to follow the state of the AI processor. 
The Sleep and Event messages allow the BLE processor to track the Operational Parameters. In particualr, some of these values 
are sent in LoRaWAN messages.

It may be useful to parse some of these messages and present them to the user. 
(Some would indeed be helpful for engineering purposes: moton detection and positive NN indications.)


## Setting UTC time

The AI processor (HX6528) needs the UTC for timestamping images in EXIF data. It has a calendar/clock hardware and software,
 but because it does not have an accurate timekeeping crystal it needs help to maintain an accurate time. 
 The BLE processor does have an accurate timekeeping crystal, and can help the AI processor. 
 
UTC time is set and retrieved in a string of this format: `2025-01-02T03:04:05Z`.
 
We operate as follows:

* The BLE processor has pretty accurate calendar clock (c. 20ppm)
* The AI processor has a less accurate calendar clock (accuracy uncertain but good enough to operate over minutes or hours without
noticable drift).
* The phone can get accurate UTC from the network and pass it to the BLE processor when it connects.
* The LoRaWAN system gets accurate UTC from the network whenever it pings the network - say every 15 minutes, 1 hour etc.
But that assumes it has LoRaWAN connectivity, which not all devices will have.
* In the absence of either external time source the BLE processor will retain a reasonably accurate time over weeks, 
with its accurate crystal.
* After power-on and until the BLE processor gets the time from the app or LoRaWAN its time starts at moidnight on 1 Jan 2024.  
* The BLE processor passes its UTC time to the AI processor every few minutes. The AI processor can thus have a 
reasonably accurate time for purposes of timestamping images.
* From the app's point of view, it should send the UTC time whenever it connects, in a command like this: `setutc 2025-01-01T01:02:03Z`.
* At present, the `setutc` command results in two responses - first from the BLE processor then from the AI processor. For some reason
the AI processor RTC setting takes 1-2 seconds, and the response reports this duration.
* If the app wants to read the time back from the BLE and/or AI processor it can (no need to, I think): `getutc` will read 
the BLE processor time and `AI getutc` will read the AI processor time.  
* I have provided functions on the AI processor for creating the timestamp in a format suitable for inclusion in EXIF. I understand that 
EXIF uses an ASCII string like "YYYY:MM:DD HH:MM:SS\0"

In the event that neither the app nor the LoRaWAN network have provided the device with its time, we should probably not try 
to add a timestamp in the EXIF. The function `iso_time_isSet()` returns a boolean.

## Setting GPS location 

The location is required for EXIF metadata, and the format within the EXIF is somewhat complex - it is stored as a binary
representation in degrees, minutes and seconds (for latitude and longitude) and meters above or below sea level
for altitude.

GPS location is set and retrieved in a string of this format: `37°48'30.50" N 122°25'10.22" W 500.75 Above`. The single-quote
character indicates degrees and the double-quote character indicates seconds. Degrees and minutes are integers. Seconds and meters
may be decimal values. The 'N' should be 'S' for the southern hemisphere and the 'W' should be 'E' for the eastern hemisphere.
The 'Above' should be 'Below' if below sea level.

We operate as follows:

* The app needs to tell the AI processor its location, based on data from the phone's GPS receiver or some other source.
* The app design can decide whether it should do that every time, automatically, on connection or whether this should be sent
by user command.
* The string representation uses the format described above, but it needs escaping. So the above string is sent like this:
`"37°48'30.50\"_N_122°25'10.22\"_W_500.75_Above"`. That is, spaces need to be replaced by underscores so that this is 
treated as a single string; there is a pair of enclosing quotes; the internal double-quote (seconds) are escaped with a back-slash.
* Thus the app needs to send a command like this: `AI setgps "37°48'30.50\"_N_122°25'10.22\"_W_500.75_Above"`
* The app may request the AI processor's GPS location with `AI getgps`.

In the event that the app has not provided the device with its location, we should probably not try to add a GPS location in the EXIF. 
I should probably add a function like `exif_gps_has_location()` that returns a boolean. (not yet implemented).

## App Behaviour on Connection

I think that the app should send a number of configuration messages as soon as it connects, without user intervention, and do this every time
(probably not just while configuring). These should include:
* Requests device ID, model, name, etc.
* Requests status, including battery voltage and LoRaWAN network status.
* Send UTC, provided that the phone has the time.
* Send GPS location, provided that the phone has this.

This information should be parsed and if appropriate presented to the user in an easy-to-process form.

At present I observe the app requesting some of this information. However it happens quite slowly with commands at 1 second intervals.
It should be possible for these commands to be issued without delays.

At present the app appears to send 'battery' requests every few seconds. There is no need for this.

The app should disconnect from the device after say 1 minute of meaningful activity.




